## 기본 CS 개념 질의응답

### 프로그래밍 언어 및 자료구조

**객체지향 언어가 갖는 특성에 대해 설명해주세요.**

객체지향 언어 혹은 프로그래밍이 갖는 특징에는 4가지가 있습니다.

추상화, 상속, 다형성, 캡슐화가 있습니다. 각각의 특징에 대해 자세히 살펴보겠습니다.

1. 추상화

추상화는 공통적으로 갖는 특성을 추출하는 것이라 할 수 있습니다. 예를 들어, 자동차와 오토바이는 모두 이동을 위한 수단이며, 전진과 후진을 할 수 있다는 공통점을 갖습니다.

이를 코드로 표현하면, 아래와 같습니다.

```` java
public interface Vehicle {
    void start(); // 시동걸기
    void moveForward(); // 전진
    void moveBackward(); // 후진
}
````

자동차와 오토바이가 갖는 공통적인 기능을 추출하여 인터페이스로 정의합니다.

> 인터페이스는 객체가 갖는 역할만을 정의하여 객체들 간의 관계를 보다 유연하게 연결하는 역할을 담당합니다. 

```` java
public class Car implements Vehicle {
    @Override
    public void moveForward() {
        System.out.println("앞으로 이동");
    }

    @Override
    public void moveBackward() {
        System.out.println("뒤로 이동");
    }
}
````

```` java
public class MotorBike implements Vehicle {
    @Override
    public void moveForward() {
        System.out.println("앞으로 이동");
    }

    @Override
    public void moveBackward() {
        System.out.println("뒤로 이동");
    }
}
````

코드를 통해 알 수 있듯이 인터페이스에 정의한 역할을 각각의 클래스의 맥락에 맞게 구현할 수 있습니다.

2. 상속

상속이란 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소를 의미합니다.

위에서 봤던 추상화의 연장선으로, 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시킵니다. 이를 통해 공통되는 특성과 기능을 반복적으로 정의할 필요 없이 한 번만 정의해두고 재사용할 수 있습니다.

앞선 예시에서 몇 가지 코드를 추가해보겠습니다.

```` java
public class Vehicle {

    String model; // 모델명
    String color; // 색
    int wheels; // 바퀴 수

    void moveForward() {
        System.out.println("앞으로 이동");
    }

    void moveBackward() {
        System.out.println("뒤로 이동");
    }
}
````

```` java
public class Car extends Vehicle {
    
    boolean isConvertible;

    void openWindow() {
        System.out.println("창문을 엽니다.");
    }
}
````

```` java
public class MotorBike extends Vehicle {

    boolean isRaceable;

    @Override
    public void moveForward() {
        System.out.println("앞으로 이동");
    }

    public void stunt() {
        System.out.println("묘기를 부립니다.");
    }
}
````

추상 클래스로 정의한 경우, extends 라는 키워들르 통해 하위 클래스로 확장하여 각각의 맥락에 맞게 재정의할 수 있습니다. 

인터페이스는 역할만 정의해두고, 하위 클래스에서 구체적인 구현을 하도록 강제하는 것에 비해 추상 클래스는 선택적으로 속성과 기능을 그대로 받아 사용하거나 재정의할 수 있습니다.

3. 다형성

다형성은 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질을 의미합니다.

Vehicle로 추상 클래스를 만들어 상황에 맞게 Car 혹은 MotorBike로 생성할 수 있듯이 하나의 타입으로 여러 가지 타입의 객체를 참조 할 수 있게 해주는 것이 다형성입니다.

이는 객체 간의 결합도를 낮춰주는 역할도 합니다. 어떠한 클래스로 구체화될 것인지 알 수 없는 상태에서도 다른 객체와의 의존 관계를 갖게 될 때 유연하게 적용될 수 있도록 해줍니다.

4. 캡슐화

캡슐화는 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것을 말합니다.

캡슐화를 하는 목적은 2가지입니다. 

- 외부로부터 클래스에 정의된 속성과 기능들을 보호하기 위해
- 내부의 동작을 감추고 외부에는 필요한 부분만 노출하기 위해

이를 구현하는 방법에는 크게 2가지가 있습니다. 

접근제어자를 활용하는 것입니다. 

public ( 공중화장실 ) : 모두 접근 가능 => 접근 제한 없음 <br/>
protected ( 호텔 내부 화장실 ) : 호텔 투숙객만 이용 가능 => 동일 패키지 혹은 다른 패키지의 하위클래스에서 접근 가능 <br/>
private ( 우리집 화장실 ) : 우리 가족만 이용 가능 => 동일 클래스 내에서만 접근 가능

[내용 출처 : 코드스테이츠](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)

**스택과 큐의 차이에 대해 설명해주세요.**

스택은 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고, TOP으로 지정한 곳을 통해서만 접근할 수 있습니다. 

TOP에는 가장 최근에 들어온 자료를 가리키고 있으며, 삽입/삭제가 발생하는 위치입니다.

따라서 스택은 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조를 갖고 있습니다.

주로 웹 브라우저의 방문기록, 역순 문쟈열 만들기, 수식의 괄호 검사 등에 사용됩니다.

큐의 사전적 의미는 줄을 서서 기다리는 것을 의미합니다. 우리가 일상에서 입장을 위해 기다리는 것과 같습니다. 그렇기에 먼저 들어온 자료가 먼저 나가는 구조입니다.

큐는 한쪽 끝에서 삽입 작업이 다른 쪽 끝에서 삭제 작업이 이루어집니다. 즉, 들어오는 곳과 나가는 곳이 다릅니다.

주로 우선순위가 같은 작업 처리, BFS 구현, 캐시 구현에 사용됩니다.

[내용 출처 : 튜나](https://devuna.tistory.com/22)

**정수형 타입에 무엇이 있는지 설명해주세요.**

자바에서 대표적으로 정수를 표현하는 자료형에는 int와 long이 있다. 

|타입|메모리 크기|표현 범위|
|-|-|-|
|byte|1 byte|-128 ~ 127|
|short|2 byte|-32,768 ~ 32,767|
|int|4 byte|-2,147,483,648 ~ 2,147,483,647|
|long|8 byte|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

> 해당 질문의 의도는 int와 long 외에 다른 타입을 알고 있는지를 묻고자 함이었습니다.

[내용 출처: 인파](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95-%EC%A2%85%EB%A5%98-%EC%B4%9D%EC%A0%95%EB%A6%AC-int-double-char-String)

### 데이터베이스

**인덱스란 무엇이며, 왜 사용하는 것인가요?**

인덱스란 책으로 비유하면 목차와 같은 것입니다. 많은 양의 데이터 속에서 특정 내용을 찾고자 할 때, 모든 내용을 찾아 보는 것은 시간이 많이 걸리는 작업입니다. 그렇기에 목차를 통해 찾고자 하는 내용이 어디에 위치해 있는지를 표시합니다. 데이터베이스에서 이를 인덱스라 합니다. 

인덱스는 쓰기 작업꽈 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 인덱스를 활용하면, 조회 외에도 수정/삭제의 성능 향상에 도움이 됩니다.

인덱스의 역할과 특징을 통해 알 수 있듯이, 조회/수정/삭제에서의 성능 향상을 위해 사용합니다.

인덱스의 장점과 단점을 추가로 설명하면, 장점으로는 조회 속도 향상과 전반적 시스템의 부하 경감이 있습니다. 단점으로는 인덱스를 관리하기 위해 데이터베이스의 약 10%에 해당하는 저장공간이 필요하며, 인덱스를 최신의 정렬 상태로 유지하기 위한 추가 작업이 필요합니다.

인덱스는 어떤 경우에 사용하면 좋을까요?

1) 규모가 작지 않은 테이블에서 <br/>
2) 삽입/수정/삭제가 자주 발생하지 않는 컬럼 혹은 <br/>
3) join이나 where, orderby에 자주 사용되는 컬럼, <br/>
4) 데이터의 중복도가 낮은 컬럼 <br/>
에 사용하는 것이 좋습니다.

[내용 출처: 망나니개발자](https://mangkyu.tistory.com/96)

**데이터베이스 설계 시, 중요하게 생각하는 바가 무엇인가요?**

이 질문의 의도는 *정규화*를 알고 있는지를 묻는 것이었습니다.

그렇다면, 정규화는 무엇일까요?

`이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정`입니다. 여기서 이상현상은 무엇을 의미하는 것일까요?

- 삭제 이상: 데이터 삭제 시, 의도와는 상관없이 다른 정보까지 연쇄적으로 삭제되는 현상
- 삽입 이상: 데이터 삽입 시, 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상
- 수정 이상: 데이터 수정 시, 의도와는 상관없이 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상

테이블을 분해하는 정규화 단계가 정의되어 있는데, 그 과정은 아래와 같습니다.

* 제 1 정규화

목표: 속성의 원자성을 확보하고 원자값이 아닌 도메인을 분해한다.

* 제 2 정규화

목표: 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거한다.

수강강좌 ( __학생번호__, __강좌이름__, 강의실, 성적 ) 의 구조를 갖는 테이블에서 아래와 같이 변경하면, 2NF를 충족합니다.

수강( __학생번호__, __강좌이름__, 성적 ) 강의실 ( __강좌이름__, 강의실 )

* 제 3 정규화

목표: 기본키를 제외한 컬럼 간의 종속성을 제거한다. 즉, 이행 함수 종속성을 제거한다.

여기서 이행 함수 종속성은 A -> B, B -> C 가 성립할 때, A -> C가 성립되는 것을 의미합니다.

* BCNF 정규화

목표: 3NF 까지 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해한다.

특강수강 ( __학생번호__, __특강이름__, 교수 ) 테이블이 있다고 할 때, 학생번호와 특강이름이 교수를 결정하고 있습니다. 또한 교수는 특강이름을 결정하는 결정자이기도 합니다.

여기서의 문제는 교수가 후보키가 아니라는 점입니다. 그렇기에 BCNF 정규화를 만족시키기 위해 아래와 같이 분해해야 합니다.

특강신청 ( __학생번호__, 교수 ) 특강교수 ( 특강이름, __교수__ )

[내용 출처 : 망나니개발자](https://mangkyu.tistory.com/110)

[내용 출처: 코딩팩토리](https://coding-factory.tistory.com/872)


**테이블 간의 조인이 무엇이며 종류와 특징에 대해 설명하시오.**

Join은 2개 이상의 테이블을 엮어서 조회하는 연산을 말합니다. 종류에는 아래와 같습니다.

- inner join : 교집합에 대해서만 조회한다.
- outer join : 매칭되는 데이터를 기준으로 좌측, 우측 혹은 전체를 같이 조회합니다.
- natural join : 컬럼명과 타입이 모두 같은 컬럼을 조건으로 사용합니다.
- self join : 자기 자신과 조인하는 것입니다.

예시를 통해 조금 더 살펴보겠습니다.

1. Inner Join

두 테이블 간의 조건에 매칭되는 데이터만을 조회합니다. 

employees( employee_id, first_name, last_name, department_id, manager)id )

departments( department_id, department_name )

```` sql

select *
from employees e inner join department d
on e.department_id = d.department_id
;

// or 

select *
from employees e join departments d
using(department_id)
;
````

2. Self Join

```` sql

select distinct(e1.employee_id), concat(first_name, ' ' , last_name)
from employees e1 join employees e2
on e1.employee_id = e2.manager_id
;

````

3. Outer Join

```` sql

select employee_id, e.department_id, d.department_name
from employees e left outer join department d
on e.department_id = d.department_id
;
````

[내용 출처 : 팡트루야](https://pangtrue.tistory.com/254)

**PK가 무엇인지 설명하시오.**

PK에 대해 설명하기 이전에 후보키에 대한 설명을 먼저 집고 넘어가겠습니다.

후보키 ( candidate key )는 릴레이션을 구성하는 속성들 중 튜플을 유일하게 식별할 수 있는 속성들의 부분집합을 의미합니다.

모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 합니다. 예를 들어, 학생이라는 릴레이션에서 "학번"이나 "주민번호"는 다른 튜플을 유일하게 구별할 수 있는 기본키로 사용할 수 있습니다.

기본키 ( primary key )는 후보키 중에서 선택한 주된 키입니다. null 값을 가질 수 없으며, 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없습니다.

[내용 출처 : Limky](https://limkydev.tistory.com/108)

### WEB

**쿠키와 세션의 차이에 대해 설명해주세요.**

쿠키와 세션에 대해 설명하기 이전에 인증과 인가에 대한 개념을 먼저 집고 넘어가겠습니다.

인증은 특정 서비스에 일정 권한이 주어진 사용자인지 확인하는 과정을 말합니다. 대표적으로 로그인이 있습니다.

인가는 한 번 인증을 받은 사용자에 대해 로그인이 되었는지 확인하고 서비스의 기능을 사용할 수 있도록 허가해주는 것을 말합니다. 인가를 구현하는 방식에는 여러가지가 있으며 여기에 해당하는 것이 쿠키와 세션입니다.

쿠키는 사용자가 방문한 웹 사이트 서버가 사용자 컴퓨터에 저장하는 작은 기록 정보 파일입니다. 

쿠키를 저장할 때, 설정한 만료시점까지 삭제가 불가능하며 key-value 형태로 이루어져 있습니다.

세션은 일정시간동안 같은 사용자로부터 들어오는 일련의 요청을 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술입니다.

세션 정보는 웹 서버에서 저장하고 관리하며, 브라우저 종료 시 삭제되기에 쿠키보다 안전합니다. 단, 대규모 요청이 들어올 경우, 서버에서 세션 정보를 관리하는 데 부하가 발생할 수 있습니다.

[내용 출처: 개인 노션](https://www.notion.so/dldmsql/b1bc415b97154b29a6c4abec4dbbe720#5bc59149e4614fb48b182946f6ce823f)

[내용 출처: 주말내집 서버 위키](https://github.com/ODOICHON/server/wiki/%5BCS-%EC%B4%9D-%EC%A0%95%EB%A6%AC%5DSummary)


**Ajax가 무엇인가요**

자바스크립트 라이브러리 중 하나로, 비동기 통신을 위한 기술입니다.. 단순하게 화면에서 데이터 조회를 하고 싶을 경우, 페이지 전체를 새로고침하지 않기 위해 사용한다고 볼 수 있습니다.

Ajax는 HTML 페이지 전체가 아닌 일부만 갱신할 수 있도록 XMLHttpRequest 객체를 통해 서버에 요청합니다.

Ajax의 장단점으로는 아래와 같습니다.

1. 장점

- 속도 향상
- 서버의 처리가 완료될 때까지 기다리지 않고 처리가 가능하다.

2. 단점

- 히스토리 관리가 되지 않는다.
- 연속으로 데이터를 요청할 경우, 서버 부하 증가
- 동일-출처 정책으로 다른 도메인과 통신 불가능하다.

[내용 출처: 99geo](https://99geo.tistory.com/65)

### INFRA

**DB 서버를 R-W로 구분하는 이유는 무엇인가요**

트래픽이 급증할 경우, 1대의 데이터베이스에 쓰기와 읽기를 모두 처리하게 되면 많은 부하가 발생하게 됩니다. 

이러한 부하 분산을 위해 읽기 전용과 쓰기 전용으로 분리하여 구성합니다.

분기하는 방식은 크게 3가지가 있습니다.

1. DBProxy 서버 이용

쿼리를 분석하여 select로 시작할 경우, read 서버로 그 외에는 write 서버로 향하게 합니다.

2. MySQL Replication JDBC Driver 이용

내부적으로 readonly 옵션이 있으며 이를 이용해 장비를 선택할 수 있습니다. 하지만 여러 문제점들이 발견되어 사용하지 않는 걸 권장합니다.

3. SpringLazyConnectionDataSourceProxy + AbstractRoutingDataSource 사용

스프링에서 Transaction readonly 옵션으로 분기 처리 후에 위의 2개 클래스로 장비 선택을 하도록 합니다.

[내용 출처: smkim](https://velog.io/@smkim104/Spring-Boot-DB-Read-Write-%EB%B6%84%EB%A6%AC)


**오토 스케일링이 무엇인가요**

오토 스케일링은 컴퓨팅 자원을 유동적으로 조절하는 기술입니다.

스케일링은 인스턴스 혹은 컴퓨팅 파워를 늘리는 것을 말하며, 2가지 방법이 있습니다.

1. 스케일업

노드의 성능 자체를 올리는 것을 말합니다.

2. 스케일아웃

규모를 늘리는 것을 말합니다. 개별 성능을 높이는 것이 아닌, 동일한 성능 혹은 특정한 성능을 가진 노드의 개수를 늘리는 것을 말합니다.

[내용 출처 : 인파](https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-EC2-%EC%98%A4%ED%86%A0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81-ELB-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-%EA%B0%9C%EB%85%90-%EA%B5%AC%EC%B6%95-%EC%84%B8%ED%8C%85-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)