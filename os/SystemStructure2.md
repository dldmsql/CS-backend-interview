# 컴퓨터 시스템 구조2

컴퓨터는 크게 cpu와 메모리, i/o 디바이스로 구성된다.

i/o 디바이스들에게는 각각 디바이스 컨트롤러가 존재한다.

디바이스 컨트롤러는 디바이스를 전담하는 작은 cpu이다.

그리고, 로컬 버퍼를 각각 갖고 있다.

i/o 디바이스가 어떤 작업을 한 뒤에 생기는 데이터를 로컬 버퍼에 저장해둔다.

그리고, cpu에게 i/o 작업이 완료되었음을 알리기 위해서 디바이스 컨트롤러가 인터럽틀르 건다.

cpu는 매 순간 메모리 어딘가에 올라와 있는 기계어를 처리한다.

0과 1의 조합으로 된 4 byte로 된 기계어를 읽고 실행한다.

cpu 안에 메모리 위치를 갖고 있는 레지스터인 program counter 레지스터가 가리키는 메모리에 올라온 명령어를 처리한다.

cpu에서 명령어를 실행하고 있으면, pc가 주소값을 증가시킨다.

프로그램이 항상 순차적으로 실행되지는 않는다.

보통 기계어 집합 중에 점프하는 인스트럭션이 있다.

이 인스트럭션을 만나면 점프해서 그 메모리 위치에 있는 명령을 처리한다.

cpu는 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다.

명령을 실행하기 전에 확인하는 게 인터럽트 라인이다.

인터럽트가 들어오면, 하던 작업을 멈추고 cpu 제어권이 운영체제로 넘어간다.

운영체제는 인터럽트마다 커널 함수로 정의되어 있다. 인터럽트 백테가 각 인터럽트 종류 별로 몇 번 라인의 인터럽트인지, 어떤 행동을 해야 하는 지 ( 처리해야 할 주소를 갖고 있다. ) 가 정의되어 있다. 

실제 해야 될 일이 인터럽트 처리 루틴이다.

cpu 안에 모드 비트가 있는데, 0이면 cpu가 모든 작업을 할 수 있고, 1이면 한정된 명령만 수행할 수 있다.

운영체제가 cpu를 갖고 있을 땐 모드 비트가 0이다.

모드 비트가 1일 땐, 사용자 프로그램이 cpu를 갖고 있을 경우이다.

사용자 프로그램을 100% 신뢰할 수 없기 때문에, 자기 메모리 주소 영역만 보고 일을 할 수 있다.

i/o 디바이스를 접근하는 것은 모드 비트가 0일 때만 가능하다. 
운영체제에게 요청을 해야 한다. 그러려면 프로그램 카운터가 운영체제를 가리켜야 하는데, 사용자 프로그램에서는 이게 불가능하다. 그래서 나온 게 시스템 콜이다. 의도적으로 인터럽트 라인을 세팅한다. 이러면 운영체제에 cpu 제어권이 넘어가니까 i/o 작업을 요청할 수 있다.

일반적인 인터럽트는 하드웨어 인터럽트이고, 소프트웨어 인터럽트는 트랩이라고 부른다. 

트랩은 사용자 프로그램이 필요에 의해 요청하는 시스템 콜과 오류에 의한 트랩이 있다.

타이머라는 하드웨어가 인터럽트를 걸 수 있다.

운영체제가 cpuㄹ르 갖고 있다가 사용자 프로그램에 cpu를 넘겨 줄 때, 모드 비트를 1로 바꾼다. 

사용자 프로그램이 cpu를 놓아주지 않는다면, 이걸 뺏어올 방법이 없다. 그래서 운영체제는 타이머에 특정 시간을 세팅해서 사용자 프로그램에게 cpu를 넘겨준다. 타이머의 시간이 되면 타이머가 cpu에 인터럽트를 걸어서 제어권을 운영체제에 넘긴다.

동기식 입출력과 비동기식 입출력

동기식 입출력

립싱크를 떠올려봐. 서로 맞추는 것을 싱크라고 한다. 시간적으로. 

i/o 는 커널을 통해서만 할 수 있다.

i/o 작업은 시간이 상당 필요하다.

유저가 이 작업을 기다렸다가 다음 작업을 하는 걸 동기식 입출력이라 한다.

유저가 이 작업을 기다리지 않고 다른 작업을 한다면 비동기식 입출력이라 한다. 이때, 작업의 완료를 알려주는 게 인터럽트이다.

i/o 요청을 한 뒤, 이 결과를 보고 다음 처리를 하는 게 보통이다. 

그렇지 않게 프로그래밍할 수도 있다.

디스크에서 무언가 읽어라고 명령을 하고, 다른 작업을 하다가 결과를 보고 그 순간부터 작업을 이어나갈 수 있다.

write는 async 하게 작업하는 게 자연스럽다.

동기식 입출력을 요청하게 되면, 기다리는 동안에 cpu를 낭비시키게 된다.

그래서 i/o 요청한 뒤에 해당 프로그램에게서 cpu를 빼앗아서 다른 프로그램에게 제어권을 준다.

그러면 cpu가 놀지 않고 작업을 처리할 수 있다.

메모리를 접근 할 수 있는 또다른 아이를 둔다. DMA. cpu의 작업 부담을 덜어주기 위함이다.

dma는 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.

빠른 입출력 장치이면 더 빈번한 인터럽트를 걸겠지 ? 

cpu의 중재 없이 디바이스 컨ㅌ트롤러가 디바이스의 로컬 버퍼의 내용을 메모리에 블록 단위로 직접 전송한다.

i/o를 할 수 있는 방법이 2가지이다.

cpu에서 실행할 수 있는 기계어에는 메모리에만 접근하는 인스트럭션과 i/o 디바이스에만 접근하는 인스트럭션이 있다.

별개의 인스트럭션으로 접근하는 것이 일반적이다.

i/o 디바이스들에 메모리 주소를 매겨서 memory mapped i/o라고 한다. 즉, 100번지 주소이면 메모리 주소를 가리키는 거고 1000번지 주소이면 i/o 디바이스를 가리키는 거라고 보면 된다.

저장장치 계층 구조

레지스터 > 캐시 메모리 > 메인 메모리 

위로 갈 수록 속도가 빠른 매체를 사용하고, 용량이 적다.

휘발성 매체이다. -> 캐시 메모리나 레지스터는 전원이 나가면 내용이 사라진다. 

cpu에서 직접 접근할 수 있는 메모리를 primary라고 하고, 직접 접근하지 못하는 것을 secondary라고 한다.

바이트 단위로 접근 가능하면 excutable하다고 한다. <- 바로 실행 가능하다.

캐싱은 재사용을 목적으로 한다. 

프로그램의 실행

프로그램은 실행 파일 형태로 파일 시스템에 저장되어 있다. 이걸 실행하면 메모리로 올라가서 프로세스가 된다. 

가상 메모리를 거쳐서 올라간다. 어떤 프로그램을 실행시키게 되면, 이 프로그램의 주속 공간이 형성된다. 0번지 부터 해서 프로그램만의 독자적인 공간이 생긴다. 코드, 데이터, 스택 영역으로 구성된다. 

코드는 기계어 코드를 담고 있고, 데이터는 전역 변수, 프로그램이 사용하는 자료구조, 스택은 함수의 리턴을 담고 있다.

이걸 물리적 메모리에 올려서 실행한다. 

커널은 항상 메모리에 올라가 있는다. 

사용자 프로그램은 항상 메모리에 올라가 있지 않는다. 주소공간 중에 당장 필요한 것들을 메모리 공간에 올려두고, 그렇지 않은 것들은 swap area에 올려둔다. 가상 메모리는 각 프로그램마다 독작적으로 갖고 있는 공간을 말한다.

파일 시스템은 전원이 나가도 내용이 유지가 된다.

swap area는 전원이 나가면 같이 사라진다. 의미 없는 정보들. 메모리 용량의 한계로 연잔성의 의미로 사용한다.

각 프로그램마다 0번지 부터 시작하는 주소 공간이 있는데, 가상 메모리에서의 주소와 물리적 메모리에서의 주소가 다르다. 주소 변환을 해주는 하드웨어 장치가 있다. 

운영체제 커널도 하나의 프로그램이기 때문에 코드, 데이터, 스택 영역을 갖는다.

코드 영역에는 커널 코드가 담겨 있다.

운영체제가 자원을 효율적으로 관리하기 때문에, 관련된 코드가 여기에 담겨 있다.

운영체제는 언제 cpu를 얻지? 인터럽트가 들어올 때. 인터럽트 처리 코드나 시스템 콜에 대한 정보가 담겨 있다.

데이터 영역에는 운영체제를 위한 자료구조가 담겨 있다. 

운영체제는 프로세스를 관리하기 때문에, 각 프로그램마다 운영체제가 관리하는 자료구조가 필요한 데, 이걸 pcb 프로세스 컨트롤 블럭이라고 부른다. 프로세스마다 pcb가 만들어져서 관리된다.

함수 호출이나 리턴할 때, 스택을 사용한다. 운영체제의 코드는 여러 프로그램들이 사용에 따라 불러서 사용한다. 어떤 프로세스가 커널 코드를 호출하는 지, 따로 구분한다. 

사용자 프로그램이 사용하는 함수

모든 프로그램이 다 함수로 작성되어 있다. 

함수는 3가지 종류가 있다.

* 사용자 정의 함수

내가 직접 작성한 함수

* 라이브러리 함수

누군가 만들어둔 함수를 가져다 쓰는 것

내 프로그램 안에 같이 포함된다.

* 커널 함수

운영체제 프로그램의 함수

커널 함수의 호출 = 시스템 콜

사용자 정의 함수나 라이브러리 함수는 프로세스의 코드 영역에 해당된다.

커널 함수는 커널 주소 공간에서 코드 영역에 해당한다.

