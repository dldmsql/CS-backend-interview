# 컴퓨터 시스템 구조

보통의 컴퓨터는 cpu와 memory로 이루어져있다.

i/o 디바이스로 구성되어 있다.

메모리는 cpu의 작업 공간이다. 

cpu에서 하는 일은 기계어를 실행한다고 한다. instruction을 실행한다.

cpu는 매 순간 메모리에서 기계어를 읽어서 실행한다.

i/o 디바이스는 별개의 디바이스들이다. 

i/o 디바이스 중 키보드나 마우스가 input 디바이스고, 프린터나 모니터는 output 디바이스이다.

하드 디스크는 i/o 디바이스로 보기도 한다. 

각각의 i/o 디바이스들은 이들을 전담하는 작은 cpu가 붙어 있는데, 이걸 디바이스 컨트롤러라고 한다.

디바이스 컨틀로러들도 그들의 작업 공간이 필요하다. 이걸 로컬 버퍼라고 부른다.

cpu와 i/o 디바이스 간의 성능 차이가 존재한다.

디스크를 cpu가 직접 관장하지 않고, 디바이스 컨트롤러가 담당한다.

cpu는 매 클럭 마다 메모리에서 인스트럭션을 읽어서 실행하고 다음 거 읽어서 실행하고 이 작업만 반복한다.

cpu 안에는 메모리보다 더 빠르면서 작은 공간인 레지스터가 있다.

interrupt line은 cpu가 항상 메모리에 있는 인스트럭션만 실행해. 다음 기계어의 주소값이 증가해. 그러면 키보드에서 어떤 입력이 들어왔다던지, 디스크에서 어떤 값을 읽어와야 하는 것들을 어떻게 알지 ? 이걸 위해서 있는데, 인터럽트 라인이다. 

키보드 입력이나 화면 출력 같이 i/o 디바이스에 접근하는 인스트럭션은 디바이스 컨트롤러를 통해 지시한다.

프로그램이 메모리 접근만 하면서 실행하다가 i/o 접근을 해야 한다면, cpu는 대기 하는 게 아니라 명령을 내리고 자기 일을 처리한다.

cpu는 굉장히 빠른 일꾼이다. 빠른 속도를 이용해서 일만 한다. cpu는 빠르면서 쉬지 않고 일을 한다. 프로그램 여러 개 동시에 실행할 때, cpu는 굉장히 빠르게 스위칭하면서 일을 처리한다.

메모리 위에서 도는 프로그램이 무한 루프를 돈다면 ? 얘한테 cpu가 넘어가면, 프로그램이 종료되지 않아. 그래서 컴퓨터 안에는 타이머라는 하드웨어를 두고 있다. 

타이머는 특정 프로그램이 cpu를 독점하는 것을 막기 위해 존재한다.

컴퓨터를 켜자마자 os가 cpu를 갖고 있다가, 타이머에 어떤 값을 세팅한 뒤에 cpu를 다른 프로그램에 넘겨준다. 

넘겨 받은 프로그램은 자기 인스트럭션 실행하다가 타이머가 되면 인터럽트를 건다. 

하나의 인스트럭션을 실행한 뒤, 인터럽트 라인 체크한다. 인터럽트 들어온 걸 확인해. 

만약에 타이머가 인터럽트를 걸어오면, cpu는 하던 일을 잠시 멈추고 제어권을 os로 자동으로 넘겨.

os가 cpu를 얻게 되면, 다음 프로그램한테 cpu를 넘겨주는 일을 한다.

이런식으로 os 가 프로그램을 관리한다.

메모리에서 인스트럭션을 실행하다가 언제가 프로그램이 종료되면 자동으로 cpu를 반납한다.

여럿이 cpu를 분할해서 사용해야 하니까 타이머를 두는 거다.

메모리하고만 작업하는 게 아니라, i/o 디바이스와의 작업을 해야 한다면, 이 프로그램이 자진해서 os에 i/o 작업 해달라고 cpu를 넘겨줘.

i/o를 접근하려면 os를 무조건 거쳐야만 한다. 

인터럽트가 들어오면 자동으로 cpu 제어권이 os로 넘어간다.

i/o 작업 요청한 게 처리되었다면, 이걸 요청한 프로그램의 한정된 시간이 남아있다면 cpu를 넘겨주고, 없다면 순서 기다렸다가 제어권을 넘겨준다.

mode bit이 0이면 os가 cpu에서 실행 중, 커널 모드라 부른다.
1일 때, 즉 cpu가 사용자 프로그램을 실행 중일 때이다.

모드 비트가 0일 땐, 무슨일이든 다 할 수 있게 되어 있다. 운영체제가 cpu를 갖고 있기 때문에.

모드 비트가 1일 땐, 제한된 인스트럭션만 실행할 수 있다.
i/o 디바이스 접근은 운영체제만 가능하다. 

사용자 프로그램은 나쁜 짓을 할 수 있기 때문에 모드 비트를 통한 보호가 필요하다.

보호와 보안을 목적으로 모드 비트를 만들었다.

타이머는 cpu 독점을 막기 위해 존재한다.

타이머에 정해진 시간을 할당한 뒤에 넘겨준다.

타이머에 세팅한 시간이 끝나면 인터럽트를 걸어서 그 프로그램으로부터 cpu를 뺏을 수 있도록 구현한 것이다.

디바이스 컨트롤러는 i/o 장치를 전담하는 작은 cpu이다.

i/o 컨트롤러를 위해 제어 레지스터와 로컬 버퍼를 갖고 있다.

제어를 위한 레지스터는 cpu가 일을 시킬 때, 그 레지스터를 통해서 명령을 내린다.

데이터를 담기 위한 로컬 버퍼는 메모리에 있는 데이터를 로컬 버퍼에 담은 뒤에 디바이스로 출력한다.

메모리도 하나의 디바이스이기 때문에, 메모리 컨트롤러가 존재한다.

메모리를 원칙적으로는 cpu만 접근할 수 있도록 한 거다.

i/o 디바이스들은 자신들의 로컬 버퍼가 존재한다. cpu는 메모리 접근도 할 수 있고, 로컬 버퍼 접근도 할 수 있다.

그런데, cpu가 너무 인터럽트를 많이 당해. 인터럽트를 많이 당하면 cpu가 효율적으로 작업을 못해.

이것 때문에 DMA 컨트롤러도 두고 있다. direct memory access controller. 이걸 두게 되면 메모리를 얘도 접근할 수 있다.

cpu와 dma 컨트롤러 사이에 동시에 메모리 접근을 방지하기 위해서 메모리 컨트롤러가 교통정리 역할을 한다.

dma 컨트롤러는 중간 중간 i/o 작업이 들어왔을 때, cpu가 로컬 버퍼의 데이터를 메인 메모리로 카피하는 작업을 대신 해준다.

이 작업들이 다 끝나면 cpu에게 인터럽트 한 번만 걸어서, cpu를 효율적으로 사용한다.

디바이스 드라이버 vs. 디바이스 컨트롤러

디바이스 컨트롤러는 각 디바이스를 전담하는 cpu이다. 이건 하드웨어이다.

디바이스 드라이버는 소프트웨어이다. 각 디바이스를 처리하기 위한 인터페이스이다. 

입출력 장치를 접근하는 것은 모두다 특권 명령으로 정의되어 있기에, os를 통해서만 접근할 수 있다.

사용자 프로그램이 디스크에세 무언가를 읽어와야 한다면, os에 부탁해야 한다. 사용자 프로그램이 os의 커널을 호출하는 것을 시스템 콜이라고 한다. 

사용자 프로그램 안에서도 메인 함수와 내부 함수들이 여러 개가 있지. cpu에서 인스트럭션을 순차적으로 실행하다가 함수를 만나면 메모리 위치를 점프할 거야. 즉, 내 프로그램 안에서 함수 호출하는 것은 메모리 위치만 바꾸는 것이다.

운영체제의 함수 호출은 메모리 주소만 바꾼다고 되는 게 아니다. 직접 i/o를 하기 위해 운영체제로 접근일 불가능하다. 
프로그램이 운영체제한테 요청하기 위해 소프트웨어적으로 인터럽트를 걸 수 있다. 모드 비트가 0으로 바뀌고, 운영체제가 cpu를 갖고 있기 때문에 디바이스 컨트롤러에게 뭔가 읽어오라고 지시할 수 있다.

소프트웨어적으로 인터럽트를 거는 걸 트랩이라고 한다. 하드웨어가 거는 인터럽트가 일바적이다. 

시스템 콜은 사용자 프로그램이 본인이 직접 인터럽트를 걸어서 운영체제에게 요청을 한다. 그래서 트랩을 건다고 해서 트랩이라고도 부른다.

운영체제는 올바른 i/o 요청인지 확인 후 수행한다.

i/o 작업 완료 후에 하드웨어 인터럽트가 걸린다.

i/o를 하기 위해 인터럽트가 2가지 걸린다. 

1. i/o 작업 요청 <- 소프트웨어 인터럽트
2. i/o 작업 완료 <- 하드웨어 인터럽트

둘을 구분할 수 있어야 한다.

현대의 운영체제는 인터럽트에 의해 구동된다고 한다.

시스템 콜은 사용자 프로그램이 운영체제한테 무언가 부탁할 때 커널 함수를 호출하는 것을 말한다.

인터럽트 관련 용어

* 인터럽트 백터

각 인터럽트 종류마다 어디 있는 함수를 호출해야 하는지 정의해둔 일종의 테이블을 인터럽트 백터라고 한다.

* 인터럽트 처리 루틴

인터럽트 종류가 여러 가지 있고, 각각의 인터럽트마다 어떤 일을 해야 하는 지, 코드 상에 다 정의가 되어 있다.

