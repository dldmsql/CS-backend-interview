# 운영체제란 무엇인가

## 운영체제란 ?
컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.

좁은 의미로는 **커널**이라 한다. <br/>
커널은 항상 메모리에 상주하는 부분이다.

넓은 의미로는 커널을 포함하여 주변 시스템 유틸리티를 포함하는 개념이다. 

**운영체제의 목적**
> 운영체제는 하드웨어와 어떻게 인터페이스를 해야 할까?

> 운영체제 위에 있는 각종 소프트웨어와 사용자와 인터액션을 해야 할까?

1. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
* 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공한다.
> 실제로 다른 프로그램들과 함께 돌아가고 있지만, 사용자로 하여금 컴퓨터만 실행하는 것 같은 환상을 제공한다.
* 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

2. 컴퓨터 시스템의 **자원을 효율적으로 관리**
* 프로세서, 기억장치, 입출력 장치 등의 효율적 관리

* 사용자 간의 형평성 있는 자원 분배
* 주어진 자원으로 최대한의 성능을 내도록

3. 사용자 및 운영체제 자신도 보호

> 운영체제가 무엇이냐 ? 자원 관리자 !

자원은 cpu나 메모리, 각종 입출력 장치, 기억 장치들을 일컫는 말이다.

컴퓨터에 cpu는 원칙적으로 하나 밖에 없다. 여러 프로그램이 동시에 실행되어야 한다면, 아주 짧은 시간안에 스위칭. 

cpu를 100ms 간격으로 프로그램들을 번갈아 가며 실행한다. 프로그램 입장에서는 자신만이 실행되는 것으로 착각한다.
> cpu 스케쥴링에서 다시 언급할 것이다.

메모리는 하나만 통으로 주어지는데, 여러 프로그램이 동시에 실행이 되어야 하기 때문에 메모리를 쪼개서 프로그램이 올라가 있다. 

그러면 어떤 프로그램에게 얼만큼 할당한 것인가의 문제가 생긴다. 각 프로그램에게 메모리 할당해주는 것도 운영체제가 한다.

각각의 주제에 대해 여러 알고리즘이 있다. cpu를 어떤 시간 간격으로 프로그램에 할당할 것인가. 누구한테 먼저 할당할 것이며 얼마만큼의 시간을 할당할 것인가.

메모리도 마찬가지. 메모리 공간은 한정되어 있는데, 이걸 어떻게 나눌 것인가. 

## 운영체제의 분류

[ 동시 작업 가능 여부 ]

* 단일 작업

한 번에 하나의 작업만 처리

* 다중 작업

동시에 2개 이상의 작업 처리

예: 윈도우에서 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있다. -> 이게 현대 방식

[ 사용자의 수 ]

* 단일 사용자


* 다중 사용자

계정을 만들어 원격 접속으로 동시 접근이 가능하다.

[ 처리 방식 ]

* 일괄 처리
> batch processing 한다고 한다.

작업 요청의 일정량 모야서 한꺼번에 처리

작업이 완전 종료될 때까지 기다려야 한다.

> 역사 속의 시스템이다.

interactive하지 않다. 작업들을 모아서 한번에 처리한다. 

* 시분할
> 현대 운영체제 방식

여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용한다.

일괄 처리 시스템에 비해 **짧은 응답 시간**을 갖는다.

interactive한 방식이다.
> 내가 키보드 두들기면 모니터에 찍히는 거다. 사람에 특화된 시스템이다.

예: 윈도우, 리눅스, ios, mac 등

* 실시간

정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 os이다.
> 데드라인이 정해져 있다.

정확한 시간을 맞춰야 하기 때문에 정교한 시스템이다.

예: 원자로/공장 제어, 미사일 제어, 반도체 장비, 로봇 제어

실시간 시스템의 개념 확장
* Hard realtime system

위에서 언급한 예시들이 여기에 해당한다.

* Soft realtime system

영화나 스트리밍 같은 예시들이 여기에 해당한다.

## 용어 정리

* Multi-tasking

cpu에서는 매 순간 하나의 작업만 하고 있으나 짧은 시간 단위로 스위칭한다. 사용자 입장에서는 동시에 처리하는 것 처럼 느껴진다.

* Multi-programming

여러 프로그램이 동시에 처리되는 것. 메모리에 여러 프로그램이 동시에 올라가는 것.

* Time-sharing

시간을 공유하는 방식. 이건 cpu를 강조한 방식.

* Multi-process

프로세스가 실행 중인 프로그램이다.

* Multi-processor

CPU가 여러 개 있는 컴퓨터를 말한다. 얘는 하드웨어적으로 다른 시스템이다.


## 운영체제의 예

* 유닉스

코드의 대부분을 C언어로 작성했다.
> 유닉스를 만들기 위해 만들어진 게 C언어이다. C언어와 기계어는 아주 가까운 고급언어이다. 

대형 컴퓨터를 위해 만들어진 운영체제이다.

멀티 태스킹 지원

높은 이식성
> 이식성이 어렵다 ? 그 컴퓨터 기계어에만 국한되게 만든 걸 말해. 유닉스는 c언어로 작성되어 있기에 다른 컴퓨터에서도 돌릴 수 있다.

소스 코드가 공개되어 있다.

최소한의 커널 구조
> 커널의 크기를 작게 만들었다. 커널은 항상 메모리에 상주하기 때문.

복잡한 시스템에 맞게 확장 용이

프로그램 개발에 용이하다.

* 윈도우

개인 PC를 위해 만들어진 운영체제이다.

GUI 기반 운영 체제

## 운영체제의 구조

[ CPU ] <> [ Memory ] <> [ Disk ] [ I/O device ]

cpu : 누구한테 CPU를 줄까 ?? -> **CPU 스케쥴링**
> cpu 스케쥴링이 번호표 방식처럼 온 순서대로 처리한다면 ?? <br/>
> 은행 업무가 1시간씩 걸리는 복잡한 상담이라면, 뒤에 대기자들은 엄청 오래 기다려야 한다. -> 비효율적 <br/>
> cpu 스케쥴링은 짧은 시간으로 줬다 뺐어다를 반복한다. 이론적으로 cpu를 가장 짧게 사용하는 애한테 먼저 주도권을 주자.

memory : 한정된 메모리를 어떻게 쪼개어 쓰지 ?? -> **메모리 관리**
> cpu에서 실행되려면 실행에 필요한 부분은 메모리에 올라와 있어야 한다. 메모리에 너무 많은 프로그램을 동시에 올리기 보다는 cpu에서 실행하기 위해서 필요한 정도만을 올리자. <br/>
> working set이라고 해서 이미 올라가 있는 프로그램만이라도 cpu에서 잘 실행되도록 하자. <br/>
> 이미 가득 차 있다면, 올라가 있는 걸 쫒아내야 한다. 미래에 사용할 것이 무엇인지 예측해서 ( 어떤 데이터가 메모리에 올라온 이후로 자주 사용되었는지 판단 ) 자주 사용되지 않는 걸 쫒아낸다.

disk : 디스크에 파일을 어떻게 보관하지 ?? -> **파일 관리**
> 디스크는 헤드가 움직이면서 데이터를 읽고 쓴다. 헤드에 가까운 요청이 들어오면 걔부터 처리한다. 엘리베이터 스케쥴링하고도 유사하다.

i/o device : 각기 다른 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 하지 ?? -> **입출력 관리**
> 인터럽트를 기준으로 관리한다.

* 프로세스 관리

프로세스 생성과 삭제

자원 할당 및 반환

프로세스 간 협력

