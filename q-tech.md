## 기술 질문 리트
> 아래 기술 질문 리스트는 보이저엑스 채용 사트에서 가져온 것입니다.

### [🏞]  PNG와 JPG의 차이점은?
대부분의 이미지는 Raster와 Vector로 나뉜다. 무조건적으로 이 두 가지로 나뉘어지는 것이 아니라 둘 다를 포함할 수도 있다.

Raster란 무엇일까? <br/>
래스터 이미지는 픽셀이라고 불리는 점들이 그리드 형태로 모여서 하나의 그림을 완성하는 것이다. 하나의 픽셀은 한 가지의 색상을 표현하고 있는데, 벡터 이미지와는 다르게 래스터 이미지는 해상도에 따라서 달라진다. 이 말은 즉, 사이즈가 하나로만 고정되어 있다는 것을 의미한다. 래스터 이미지를 크게 변형하면 픽셀도 함께 커지게 되고, 결과적으로 픽셀이 쪼개지거나 이미지가 흐려지게 된다. 래스터 이미지는 일반적으로 사진, 디지털 아트워크, 웹 그래픽에서 사용된다. 

래스터 이미지는 포맷이 데이터를 어떻게 처리하는 가에 따라 손실 이미지가 될 수도 있고, 무손실 이미지가 될 수도 있다. 일반적으로 손실 이미지 파일은 무손실 이미지 파일보다 용량이 더 작기 때문에, 파일의 크기와 다운로드 속도가 중요한 온라인 환경에서 주로 사용된다.

무손실 이미지 포맷은 원본 파일에 있는 모든 데이터를 포함하고 있다. 파일이 압축되어 있더라도 무손실 이미지의 경우에는 원래 상태로 재구성할 수 있다.

JPEG/JPG

JPEG는 온라인에서 가장 널리 사용되는 포맷 중 하나이며 무손실 래스터 포맷이다. 사진 이메일 그래픽, 배너 광고 등의 커다란 이미지 등에서 일반적으로 사용된다. JPEG 이미지는 파일 크기를 엄청나게 줄일 수 있는 슬라이딩 스케일 압축 방식을 사용하기 때문에 이미지가 더 많이 압축될수록 부자연스럽고, 픽셀처럼 보이는 현상이 더 늘아나게 된다.

GIF

GIF는 Graphic Interchange Format의 약자로 무손실 래스터 포맷이다. 이것 역시 웹에서 많이 사용되는데, 배너 광고, 이메일 이미지, 소셜 미디어 아이콘 등에서 애니메이션 이미지로 많이 사용된다. GIF는 무손실 래스터 포맷이긴 하지만 색상이나 이미지 정보를 줄이는 등 설정값을 아주 다양하게 변경할 수 있기 때문에 파일 용량을 줄일 수 있다.

PNG

Portable Network Graphics의 약자로 무손실 래스터 이미지이다. 투명한 성질도 갖고 있고, 색상의 depth도 훨씬 더 깊기 때문에 수백만 가지의 색상을 표현할 수 있다. PNG는 웹에서 하나의 표준이며, 온라인에서 가장 많이 사용되는 이미지이다. 

JPG vs. PNG

둘 다 무손실 래스터 이미지이다. 고퀄리티의 투명한 웹 그래픽이 필요한 경우에는 PNG를 사용하는 것이 좋고 사진이나 아트워크 작업을 하는 경우에는 용량이 매우 커질 수 있기 때문에 JPG를 사용하는 것이 좋다.

벡터 이미지란 무엇일까?

벡터 이미지는 점, 선, 곡선 등을 컴퓨터가 계산하는 디지털 아트워크이다. 벡터 이미지 안에는 기본적으로 수많은 수학 방정식을 포함하고 있으며, 각각의 '방정식'들은 색상, stroke, 두께 등에 관한 정보를 갖고 있기 때문에 이를 이용해서 특정한 모양을 만들어낼 수 있다. 래스터와 다르게 해상도에 의존적이지 않다. 크기를 줄이거나 늘리더라도 그 안의 디테일이 사라진다거나 픽셀 현상이 나타나지 않는다. 언제나 이미지가 동일한 모습을 유지하기 때문에, 벡터 이미지에서는 손실 또는 무손실 타입이라는 것이 존재하지 않는다. 벡터 이미지는 일반적으로 로고, 아이콘, 폰트, 디지털 일러스트 등에 사용된다.

출처 : [여기](https://blog.wishket.com/jpg-vs-png-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%8C%8C%EC%9D%BC-%ED%98%95%EC%8B%9D%EC%97%90-%EC%88%A8%EA%B2%A8%EC%A7%84-%EB%B9%84%EB%B0%80/) 참고

### 요약

PNG와 JPG는 둘다 래스터 이미지 포맷이며, 이는 픽셀이라 불리는 점들이 모여 하나의 그림을 이루는 것을 말한다. JPG는 슬라이딩 압축 기술을 이용해 파일의 크기를 줄임으로써 압축될수록 이미지가 부자연스럽게 보인다는 특징이 있다. 반면 PNG는 투명도나 색상의 depth가 훨씬 더 깊어 고퀄리티의 이미지를 만들 때 사용한다.

### [👩🏻‍💻]  Dynamic Programming이란?
자료구조의 동적할당에서 '동적'은 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법을 의미한다. 그러나 알고리즘에서 'Dynamic Programming'이 '동적'은 기억하는 것에 가깝다. 

예를 들어보자. 피보나치 수열 문제를 단순 재귀 함수로 구현을 하면 시간복잡도 O(2^n)을 갖게 된다. 

```` bash
class Example {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        System.out.println(fibo(n));
    }

    static int fibo(int x) {
        if (x==1 || x==2) return 1;
        return fibo(x-1) + fibo(x-2);
    }
}
````
중복되는 부분을 좀 더 효율적으로 개선할 방법은 없을까? 여기서부터 시작되는 게 DP이다. <br/> 
DP 문제가 성립할 조건은 아래와 같다.
1. 최적 부분 구조 <br/> 
    상위 문제를 하위 문제로 나눌 수 있으며, 하위 문제의 답을 모아서 상위 문제를 해결할 수 있다.
2. 중복되는 부분 문제<br/> 
    동일한 작은 문제를 반복적으로 해결해야 한다.

이쯤에서 다시 정리해보자. DP 기법은 무엇일까?<br/> 
이미 계산된 결과(하위 문제)를 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 설계함으로써 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다.

구현 방법은 일반적으로 Top-down과 Botton-up 이 있다.

Top-down 방식은 상위 문제를 해결하기 위해 하위 문제를 재귀적으로 호출하는 방식이다. 이때 이미 해결한 하위 문제를 저장해 두기 위해 Memoization을 사용한다. 

아래 코드를 통해 살펴보자.

```` bash
class TopDown {
    static int[] dp; // Memoization에 사용될 배열을 정의한다.
    public static void main(String[] argds) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        dp = new int[n+1]; 
        System.out.println(fibo(n));
    }

    static int fibo(int x) {
        if (x==1 || x==2) return 1;
        if (dp[x] != 0) return dp[x]; // 이미 해결한 문제라면 그 값을 반환한다.
        dp[x] = fibo(x-1) + fibo(x-2);
        return dp[x];
    }
}
````

Bottom-up은 하위에서부터 문제를 해결해나가며 먼저 계산했던 문제를 활용해서 상위 문제를 해결해나가는 방식이다. 

아래 코드를 통해 살펴보자.

```` bash
class BottomUp{
    static int[] dp;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        dp = new int[n+1];
        System.out.println(fibo(n));
    }

    static int fibo(int x) {
        dp[1] = 1; 
        dp[2] = 1;
        for (int i = 3; i < x +1; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[x];
    }
}
````
위에서부터 계속 언급되었던 Memoization은 무엇일까? <br/> 
DP 구현 방법 중 하나로, 한 번 계산한 결과를 메모리 공간에 메모하는 기법을 말한다. 이를 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기에 함수 호출 횟수를 줄일 수 있다.

Memoization의 특징은 아래와 같다.
1. 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
2. 값을 기록해 둔다는 점에서 캐싱이라 한다.
3. DP에만 한정되는 개념이 아니다. ( DP가 아닌 다른 방식으로도 사용될 수 있다. )

마지막으로 DP와 분할정복의 차이에 대해 정리하자.

최적 부분 구조는 분할정복 방식으로도 풀 수 있다. DP와 분할 정복은 해당 문제가 최적 부분 구조의 조건을 가질 때 사용할 수 있다. 즉, 상위 문제를 작게 하위 문제로 나누어 해결할 수 있다.

둘의 차이는 하위 문제의 중복이다.<br/> 
하위 문제가 독립적이지 않고 중복이 되는 경우에는 DP가 분할정복보다 더 나은 시간복잡도를 갖는다. 분할정복에서는 동일한 하위 문제가 각각 독립적으로 구성되기 때문이다.

### 요약

DP는 이미 계산된 결과를 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 설계함으로써 메모리를 적절히 사용하여 수행 시간의 효율성을 높이는 방법이다. Top-down과 Botton-Up 방식이 있으며, DP 문제가 성립하기 위해서는 최적 부분 구조와 중복되는 부분 문제라는 점을 충족해야 한다.

출처 : [여기](https://loosie.tistory.com/150) 참고

- [ ]  Virtual Memory란?
- [ ]  Semaphore란?
- [ ]  Cache란?
- [ ]  Garbage Collection이란?
- [ ]  Database Index 추가의 장단점은?
- [ ]  NoSQL의 장단점은?
- [ ]  공유기의 원리는?
- [ ]  HTTP/2의 특성은?
- [ ]  비대칭 암호화란?
- [ ]  Node.js의 특징은?
- [ ]  HDD, SSD, DRAM 각각의 성능은?
- [ ]  Memory Leak 디버깅은?
- [ ]  GIT의 장점은?